Shell 变量的**作用域（Scope）**，就是 Shell 变量的有效范围（可以使用的范围）。

在不同的作用域中，同名的变量不会相互干涉，就好像 A 班有个叫小明的同学，B 班也有个叫小明的同学，虽然他们都叫小明（对应于变量名），但是由于所在的班级（对应于作用域）不同，所以不会造成混乱。但是如果同一个班级中有两个叫小明的同学，就必须用类似于“大小明”、“小小明”这样的命名来区分他们。

Shell 变量的作用域可以分为三种：
- 有的变量可以在当前 Shell 会话中使用，这叫做**全局变量（global variable）**；
- 有的变量只能在函数内部使用，这叫做**局部变量（local variable）**；
- 而有的变量还可以在其它 Shell 中使用，这叫做**环境变量（environment variable）**。

## 全局变量

所谓全局变量，就是指变量在当前的整个 Shell 会话中都有效。每个 Shell 会话都有自己的作用域，彼此之间互不影响。**在 Shell 中定义的变量，默认就是全局变量**。

想要实际演示全局变量在不同 Shell 会话中的互不相关性，可在图形界面下同时打开两个 Shell，或使用两个终端远程连接到服务器（SSH）。

首先打开一个 Shell 窗口，定义一个变量 a 并赋值为 1，然后打印，这时在同一个 Shell 窗口中是可正确打印变量 a 的值的。然后再打开一个新的 Shell 窗口，同样打印变量 a 的值，但结果却为空，如图 1 所示。

![图1：打开两个 Shell 会话](http://c.biancheng.net/uploads/allimg/180930/1-1P930113JUZ.png)

这说明全局变量 a 仅仅在定义它的第一个 Shell 中有效，对其它 Shell 没有影响。这很好理解，就像小王家和小徐家都有一部电视机（变量名相同），但是同一时刻小王家和小徐家的电视中播放的节目可以是不同的（变量值不同）。

需要强调的是，全局变量的作用范围是当前的 Shell 会话，而不是当前的 Shell 脚本文件，它们是不同的概念。打开一个 Shell 窗口就创建了一个 Shell 会话，打开多个 Shell 窗口就创建了多个 Shell 会话，每个 Shell 会话都是独立的进程，拥有不同的进程 ID。在一个 Shell 会话中，可以执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。

例如，现在有两个 Shell 脚本文件，分别是 a.sh 和 b.sh。a.sh 的代码如下：
```
#!/bin/bash
echo $a
b=200
```
b.sh 的代码如下：
```
#!/bin/bash
echo $b
```
打开一个 Shell 窗口，输入以下命令：
```
$ a=99
$ . ./a.sh
99
$ . b.sh
200
$
```
从输出结果可以发现，在 Shell 会话中以命令行的形式定义的变量 a，在 a.sh 中有效；在 a.sh 中定义的变量 b，在 b.sh 中也有效

## 局部变量

Shell 也支持自定义函数，但是 Shell 函数和 C/C++、Java 等其他编程语言函数的一个不同点就是：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。请看下面的代码
```
#!/bin/bash
#定义函数
function func(){
    a=99
}
#调用函数
func
#输出函数内部的变量
echo $a
```
输出结果：
99

a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。

要想变量的作用域仅限于函数内部，那么可以在定义时加上local命令，此时该变量就成了局部变量。请看下面的代码：
```
#!/bin/bash
#定义函数
function func(){
    local a=99
}
#调用函数
func
#输出函数内部的变量
echo $a
```
输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。

Shell 变量的这个特性和 JavaScript 中的变量是类似的。在 JavaScript 函数内部定义的变量，默认也是全局变量，只有加上var关键字，它才会变成局部变量。

## 环境变量

全局变量只在当前 Shell 会话中有效，如果使用export命令将它导出，那么它就在所有的子 Shell 中也有效了，这称为“环境变量”。

环境变量被创建时所处的 Shell 被称为父 Shell，如果在父 Shell 中再创建一个 Shell，则该 Shell 被称作子 Shell。当子 Shell 产生时，它会继承父 Shell 的环境变量为自己所用，所以说环境变量可从父 Shell 传给子 Shell。不难理解，环境变量还可以传递给孙 Shell。

>注意，环境变量只能向下传递而不能向上传递，即“传子不传父”。

在一个 Shell 中创建子 Shell 最简单的方式是运行 bash 命令，如图 2 所示。

![图2：进入子 Shell](http://c.biancheng.net/uploads/allimg/180930/1-1P930161239128.png)

通过`exit`命令可以一层一层地退出 Shell。

下面演示一下环境变量的使用：
```
$ a=22      #定义一个全局变量
$ echo $a    #在当前Shell中输出a，成功
22
$ bash    #进入子Shell
$ echo $a    #在子Shell中输出a，失败

$ exit    #退出子Shell
exit
$ export a    #将a导出为环境变量
$ bash    #重新进入子Shell
$ echo $a    #在子Shell中再次输出a，成功
22
$ exit    #退出子Shell
exit
$ exit    #退出父Shell，结束整个Shell会话
```
可以发现，默认情况下，a 在子 Shell 中是无效的；使用 `export` 将 a 导出为环境变量后，在子 Shell 中就可以使用了。

`export a`这种形式是在定义变量 a 以后再将它导出为环境变量，如果想在定义的同时导出为环境变量，可以写作`export a=22`。

注意，本节我们一直强调的是环境变量在子 Shell 中有效，并没有说它在所有的 Shell 种有效；如果你通过终端创建一个新的 Shell，那么它就不是当前 Shell 的子 Shell，环境变量对这个 Shell 就是无效的。

此外，通过`export`命令导出的环境变量是临时的，关闭 Shell 会话后它就销毁了。所以，这种环境变量也只是在局部范围内起作用，并不影响所有 Shell。

如果想让环境变量在所有 Shell 中都有效，并且能够永久保存，在关闭 Shell 后也不丢失，那么就需要把环境变量写入启动文件。至于如何写入文件，请大家自行百度，这里就不再赘述了